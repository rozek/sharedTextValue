<!DOCTYPE html>
<html lang="en" charset="utf-8" style="width:100%">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

  <meta name="viewport" content="minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

  <meta name="apple-mobile-web-app-capable"          content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black"/>
  <meta name="format-detection"                      content="telephone=no">

  <style name="mobile-prologue">
    html {
      text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      -webkit-text-size-adjust: 100%;
      -o-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
    }

    html, body {
      width:99%; height:99%;
    }

    html { overflow:hidden scroll }
  </style>

<base href="https://rozek.github.io/sharedTextValue" />
  <style name="white-textured-background">
    html, body {
      background-color: white;
      background-image: url(./common/BinaryTexture_white.jpg);
      background-repeat:repeat;

      font-family:'Source Sans Pro','Helvetica Neue',Helvetica,Arial,sans-serif;
      font-size:14px; font-weight:400; color:black;
      line-height:150%;
    }

    * {
      -moz-box-sizing:border-box; -webkit-box-sizing:border-box; box-sizing:border-box;
    }
  </style>
  <script name="clear-console">
    if (typeof console.clear === 'function') {
      console.clear()
    }
  </script>

  <script type="importmap">
  {
    "imports": {
      "javascript-interface-library": "./js/javascript-interface-library.esm.js",
      "JIL":                          "./js/javascript-interface-library.esm.js",

      "preact-with-htm": "./js/preact-with-htm-bundle.js",
      "preact-with-htm/":"./js/preact-with-htm/modules/"
    }
  }
  </script>
 </head>
 <body>

  <script type="module" src="https://rozek.github.io/automerge-bundle/dist/automerge-bundle.js"></script>
  <script src="https://unpkg.com/javascript-interface-library"></script>

  <script type="module">
/*******************************************************************************
*                                                                              *
*                               shared TextValue                               *
*                                                                              *
*******************************************************************************/
import { quoted } from 'javascript-interface-library';
let automerge, isValidAutomergeUrl, Repo; // will be set later
let IndexedDBStorageAdapter; // dto.
let BrowserWebSocketClientAdapter, BroadcastChannelNetworkAdapter;
import { render, html, Component } from 'htm/preact';
/**** "global" variables ****/
const DefaultURL = 'automerge:4KJrmBdEJdkfesNUnWzZEMeKkBEK';
let sharedRepo;
let sharedURL = DefaultURL;
let sharedDocHandle;
let MainView;
/**** ApplicationView ****/
class ApplicationView extends Component {
    constructor() {
        super(...arguments);
        this.state = 0;
    }
    componentDidMount() {
        MainView = this;
    }
    rerender() {
        this.setState(this.state + 1);
    }
    render(PropSet) {
        return html `
<div style="
  display:flex; flex-flow:column nowrap; align-items:stretch;
  width:480px; height:100%;
">
  <h2 style="padding-bottom:4px; border-bottom:solid 1px gray">Shared TextValue</h2>

  <div>
    This little programming experiment shares a given text
    using <a href="https://automerge.org/">Automerge</a>.
  </div>

  <div><b>Nota bene: this is not a shared text editor!</b></div>

  <${PaneSwitcher}/>

  <div style="border-top:solid 1px gray"></div>
</div>`;
    }
}
/**** PaneSwitcher ****/
class PaneSwitcher extends Component {
    render(PropSet) {
        return html `
<div style="flex:1 1 auto">
<${this.relevantPane}/>
</div>`;
    }
    relevantPane() {
        switch (true) {
            // @ts-ignore TS2339 allow "window.automerge"
            case (window.automerge == null):
                return html `<${SplashPane}/>`;
            case (sharedDocHandle == null):
                return html `<${StartPane}/>`;
            case (sharedDocHandle.state === 'deleted'):
                window.alert('The requested document has been deleted');
                resetSession();
                break;
            case (sharedDocHandle.state === 'unavailable'):
                window.alert('The requested document is not available');
                resetSession();
                break;
            case (sharedDocHandle.state !== 'ready'):
                return html `<${LoadPane}/>`;
            default:
                return html `<${ApplicationPane}/>`;
        }
    }
}
/**** centered ****/
class centered extends Component {
    render(PropSet) {
        return html `
<div style="
  display:inline-block; position:relative;
  width:100%; height:100%;
  max-height:240px;
">
  <div style="
    display:block; position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
  ">${PropSet.children}</div>
</div>`;
    }
}
/**** SplashPane ****/
class SplashPane extends Component {
    render(PropSet) {
        return html `
<${centered}>
  <span style="white-space:nowrap">Automerge is loading, please wait...</span>
</>`;
    }
}
/**** StartPane ****/
class StartPane extends Component {
    constructor() {
        super(...arguments);
        this.state = 0;
        this.URL = sharedURL || '';
    }
    rerender() {
        this.setState(this.state + 1);
    }
    render(PropSet) {
        let URLisValid = false;
        let URLMessage = '';
        switch (true) {
            case (this.URL.trim() === ''):
                URLMessage = '(no URL given)';
                break;
            case (!isValidAutomergeUrl(this.URL) &&
                !isValidAutomergeUrl('automerge:' + this.URL)):
                URLMessage = '(invalid URL given)';
                break;
            default:
                URLisValid = true;
        }
        if (URLisValid) {
            sharedURL = (this.URL.startsWith('automerge:') ? this.URL : 'automerge:' + this.URL);
        }
        else {
            sharedURL = '';
        }
        return html `
<p>
  Press <b>[New]</b> to create a new shared document or enter a valid
  Automerge URL and press <b>[Open]</b> to open an existing one.
</p>

<table>
 <tr>
  <td>URL:</td>
  <td>
    <input type="text" style="margin:0px 4px 0px 4px; width:320px"
      placeholder="enter URL here"
      value=${this.URL}
      onInput=${(Event) => { this.URL = Event.target.value; this.rerender(); }}
    />
  </td><td>
    <button style="width:80px" disabled=${!URLisValid} onClick=${openSession}>Open</button>
  </td>
 </tr><tr>
  <td></td>
  <td>
    <span style="color:red; margin-left:6px">${URLMessage}</span>
  </td><td>
    <button style="width:80px" onClick=${createSession}>New</button>
  </td>
 </tr>
</table>`;
    }
}
/**** LoadPane ****/
class LoadPane extends Component {
    render(PropSet) {
        return html `
<${centered}>
  <div style="white-space:nowrap">
    Loading document ${quoted(sharedURL)}
    <br>
    please wait...
  </div>
</>`;
    }
}
/**** ApplicationPane ****/
class ApplicationPane extends Component {
    constructor() {
        super(...arguments);
        this.TextToShow = sharedDocHandle.docSync().Text;
    }
    render(PropSet) {
        let thisElement = this.base;
        let TextToShow = ((thisElement != null) && (document.activeElement != null) &&
            (document.activeElement.tagName === 'TEXTAREA') &&
            thisElement.contains(document.activeElement)
            ? this.TextToShow
            : sharedDocHandle.docSync().Text || '');
        let externalChangesPending = (this.TextToShow !== sharedDocHandle.docSync().Text);
        let my = this;
        function onInput(Event) {
            const TextToShare = Event.target.value;
            sharedDocHandle.change((Doc) => {
                Doc.Text = my.TextToShow = TextToShare;
            });
        }
        function onBlur(Event) {
            const sharedText = sharedDocHandle.docSync().Text;
            if (sharedText !== TextToShow) {
                my.TextToShow = sharedText;
                MainView.rerender();
            }
        }
        return html `
<table style="width:100%; margin-top:14px">
 <tr>
  <td>URL:</td>
  <td>
   <input type="text" readonly
     style="margin-left:4px; width:320px"
     value=${sharedURL}
   />
  </td><td>
    <button style="width:80px" onClick=${resetSession}>Close</button>
  </td>
 </tr><tr>
  <td colspan="3">
   <textarea style="width:100%; min-height:200px"
     value=${TextToShow} placeholder="(enter your text here)"
     onInput=${onInput} onBlur=${onBlur}
   ></textarea>
  </td>
 </tr><tr>
  <td colspan="3">
   <p>
    Your input will be immediately shared, but external changes only shown
    while the text editor does not own the keyboard focus.
   </p>
  </td>
 </tr><tr>
  <td colspan="3">${externalChangesPending ? '(there are exteral changes pending)' : ''}</td>
 </tr>
</table>`;
    }
}
/**** startApplication ****/
function startApplication() {
    ({
        next: automerge, isValidAutomergeUrl, Repo,
        IndexedDBStorageAdapter,
        BrowserWebSocketClientAdapter, BroadcastChannelNetworkAdapter
        // @ts-ignore TS2339 allow "window.automerge"
    } = window.automerge);
    sharedRepo = new Repo({
        network: [
            new BroadcastChannelNetworkAdapter(),
            new BrowserWebSocketClientAdapter('wss://sync.automerge.org')
        ],
        storage: new IndexedDBStorageAdapter(),
    });
    MainView.rerender();
}
/**** createSession ****/
function createSession() {
    sharedDocHandle = sharedRepo.create();
    sharedURL = sharedDocHandle.url;
    sharedDocHandle.on('change', (Event) => {
        MainView.rerender();
    });
    MainView.rerender();
}
/**** openSession ****/
function openSession() {
    sharedDocHandle = sharedRepo.find(sharedURL);
    sharedDocHandle.on('change', (Event) => {
        MainView.rerender();
    });
    sharedDocHandle.whenReady().then(() => {
        MainView.rerender();
    });
    MainView.rerender();
}
/**** resetSession ****/
function resetSession() {
    sharedDocHandle = undefined;
    sharedURL = undefined;
    MainView.rerender();
}
render(html `<${ApplicationView}/>`, document.body);
/**** "automerge" must be available before application may be started ****/
// @ts-ignore TS2339 allow "window.automerge"
if (window.automerge == null) {
    document.addEventListener('automerge', startApplication);
}
else {
    startApplication();
}

  </script>
 </body>
</html>
